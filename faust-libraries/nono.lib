//################################ ambisonic.lib ###############################
// Faust Ambisonic library. Its official prefix is `mg`.
//##############################################################################
// A library of Michael Gerzon's concepts for Faust organized in 5 sections:
//
// * Michael Gerzon early works
// * A to B and viceversa matrix
// * Encoders
// * Decoders
// * Tools
//
//******************************************************************************
// written by Giuseppe Silvi - 2019
// based on Michael Gerzon early works
//
//******************************************************************************
// It should be used using the `[...]` environment:
//
// ```
// [...] = library("libraryName");
// process = [...].functionCall;
// ```
//
// Another option is to import `stdfaust.lib` which already contains the `[...]`
// environment:
//
// ```
// import("stdfaust.lib");
// process = [...].functionCall;
// ```
//##############################################################################

declare name "Faust Ambisonic Element Library";
declare version "0.1";
declare author "Giuseppe Silvi";
declare license "CC4";

// ------------------------------------------------------------------ HARMONIZER
harmonizer = ef.transpose(400,300,(vslider("HARMONIZER (cents) [style:knob]", 0, -2600, +100, 1) : *(0.01): si.smoo));

// ------------------------------------------------------ 8 DELAY BANK ODD-FBACK
delbank = _ <: (+<: de.delay(D1,D1), de.delay(D2,D2))~*(fbgain1),
               (+<: de.delay(D3,D3), de.delay(D4,D4))~*(fbgain2),
               (+<: de.delay(D5,D5), de.delay(D6,D6))~*(fbgain3),
               (+<: de.delay(D7,D7), de.delay(D8,D8))~*(fbgain4);

// ---------------------------------------------------------------- REVERB 4 SEC
rev_quattro(N,NB,BBSO) = _ <: re.fdnrev0(MAXDELAY,delays,BBSO,freqs,durs,loopgainmax,nonl) :> *(gain), *(gain)
with{
	MAXDELAY = 8192; // sync w delays and prime_power_delays above
	defdurs = (3.00, 4.0, 6.5, 4.5, 2.0); // NB default durations (sec)
	deffreqs = (350, 1250, 3500, 8000); // NB-1 default crossover frequencies (Hz)
	fdn_group(x)  = vgroup("FDN REVERB", x);
	freq_group(x)   = fdn_group(hgroup("[1] Crossover Frequencies", x));
	t60_group(x)    = fdn_group(hgroup("[2] Band Decay Times (T60)", x));
	path_group(x)   = fdn_group(vgroup("[3] Room Dimensions", x));
	revin_group(x)  = fdn_group(hgroup("[4] Input Controls", x));
	nonl_group(x)   = revin_group(vgroup("[4] Nonlinearity",x));
	quench_group(x) = revin_group(vgroup("[3] Reverb State",x));
	nonl = nonl_group(hslider("[style:knob] [tooltip: nonlinear mode coupling]", 0, -0.999, 0.999, 0.001));
	loopgainmax = 1.0-0.5*quench_group(button("[1] Clear [tooltip: Hold down to clear the reverberator]"));
	pathmin = path_group(hslider("[1] min acoustic ray length [unit:m] [scale:log]", 12.0, 0.1, 63, 0.1));
	pathmax = path_group(hslider("[2] max acoustic ray length [unit:m] [scale:log]", 63.0, 0.1, 63, 0.1));
	durvals(i) = t60_group(nentry("[%i] %i [unit:s]",ba.take(i+1,defdurs), 0.1, 100, 0.1));
 durs = par(i,NB,durvals(NB-1-i));
	freqvals(i) = freq_group(nentry("[%i] Band %i upper edge in Hz [unit:Hz]",ba.take(i+1,deffreqs), 100, 10000, 1));
 freqs = par(i,NB-1,freqvals(i));
	delays = de.prime_power_delays(N,pathmin,pathmax);
	gain = hslider("[3] Output Level (dB) [unit:dB][tooltip: Output scale factor]", -40, -70, 20, 0.1) : ba.db2linear;
};

// ---------------------------------------------------------------- REV80
rev_ottanta(N,NB,BBSO) = _ <: re.fdnrev0(MAXDELAY,delays,BBSO,freqs,durs,loopgainmax,nonl) :> *(gain), *(gain), *(gain), *(gain)
with{
	MAXDELAY = 8192; // sync w delays and prime_power_delays above
	defdurs = (43.00, 84.0, 66.5, 44.5, 22.0); // NB default durations (sec)
	deffreqs = (350, 1250, 3500, 8000); // NB-1 default crossover frequencies (Hz)
	fdn_group(x)  = vgroup("FDN REVERB", x);
	freq_group(x)   = fdn_group(hgroup("[1] Crossover Frequencies", x));
	t60_group(x)    = fdn_group(hgroup("[2] Band Decay Times (T60)", x));
	path_group(x)   = fdn_group(vgroup("[3] Room Dimensions", x));
	revin_group(x)  = fdn_group(hgroup("[4] Input Controls", x));
	nonl_group(x)   = revin_group(vgroup("[4] Nonlinearity",x));
	quench_group(x) = revin_group(vgroup("[3] Reverb State",x));
	nonl = nonl_group(hslider("[style:knob] [tooltip: nonlinear mode coupling]", 0, -0.999, 0.999, 0.001));
	loopgainmax = 1.0-0.5*quench_group(button("[1] Clear [tooltip: Hold down to clear the reverberator]"));
	pathmin = path_group(hslider("[1] min acoustic ray length [unit:m] [scale:log]", 12.0, 0.1, 63, 0.1));
	pathmax = path_group(hslider("[2] max acoustic ray length [unit:m] [scale:log]", 63.0, 0.1, 63, 0.1));
	durvals(i) = t60_group(nentry("[%i] %i [unit:s]",ba.take(i+1,defdurs), 0.1, 100, 0.1));
 durs = par(i,NB,durvals(NB-1-i));
	freqvals(i) = freq_group(nentry("[%i] Band %i upper edge in Hz [unit:Hz]",ba.take(i+1,deffreqs), 100, 10000, 1));
 freqs = par(i,NB-1,freqvals(i));
	delays = de.prime_power_delays(N,pathmin,pathmax);
	gain = hslider("[3] Output Level (dB) [unit:dB][tooltip: Output scale factor]", -40, -70, 20, 0.1) : ba.db2linear;
};

// ------------------------------------------------------------------- HALAPHONE
halaphon = sp.spat(4, hramp, hdist) : halmeters
  with{
    hramp = os.lf_sawpos(1.0/(hslider("[01] h1 time", 3.0, -23.0, 23.0, 0.01)));
    hdist = hslider("[02] h1 distance", 1, 0, 1, 0.01);
    h1(v) = vgroup("Ch %v", hmeter);
    halmeters = vgroup("h1 meters", par(i, 4, h1(i)));
    hmeter(x)		= attach(x, envelop(x) : hbargraph("[05][unit:dB] Meter", -70, +5));
    envelop = abs : max ~ -(1.0/ma.SR) : max(ba.db2linear(-70)) : ba.linear2db;
};
